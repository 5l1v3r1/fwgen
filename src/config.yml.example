# Example ipsets for use in the iptables rules via the set module
#ipsets:
#  servers_v4:
#    type: hash:net
#    entries:
#      - 192.168.0.0/24
#      - 192.168.1.0/24
#  servers_v6:
#    type: hash:net
#    options: family inet6
#    entries:
#      - fd12:3456:789a:1::/64
#      - fd12:3456:789a:2::/64
#  servers:
#    type: list:set
#    entries:
#      - servers_v4
#      - servers_v6
#  dns_servers:
#    type: hash:ip
#    entries:
#      - 4.4.4.4
#      - 8.8.4.4

# You may override the default filter policies of "DROP"
#policies:
#  ip:
#    filter:
#      INPUT: ACCEPT
#      FORWARD: ACCEPT
#      OUTPUT: ACCEPT
#  ip6:
#    filter:
#      INPUT: ACCEPT
#      FORWARD: ACCEPT
#      OUTPUT: ACCEPT
#

# In some very rare cases you may want to put some rules even before the default
# rules. This is useful if you want to do some processing even on packets that are
# part of an established session.
#pre_default:
#  rules:
#    ip:
#     filter:
#       FORWARD:
#         - ...

# If you have iptables logic that you use often, create those here
#helper_chains:
#  ip:
#    filter:
#      LOG_REJECT:
#        - '-j LOG --log-level warning --log-prefix "IPTABLES_REJECT: "'
#        - -j REJECT

# You can add global rules that are processed before zone dispatching here.
# These will be hit for all interfaces, although they are still processed after
# the default rules.
#global:
#  rules:
#    ip:
#      raw:
#        # Add TFTP conntrack helper (new behaviour as of kernel 4.7)
#        PREROUTING:
#          - -p udp -d ${pxe} --dport 69 -j CT --helper tftp

#zones:
#  dmz:
#    interfaces:
#      - eth3
#      - eth4
#  lan:
#    interfaces:
#      - eth0
#      - eth1
#    rules:
#      ip:
#        filter:
#          INPUT:
#            - -p tcp --dport 22 -j ACCEPT
#            - -p icmp --imcp-type echo-request -j ACCEPT
#          OUTPUT:
#            - -j ACCEPT
#      ip6:
#        filter:
#          ...


#
# Complete minimal example for a classic IPv4 two interface gateway with NAT
#
# The default policy is DROP for filter table for both IPv4 and IPv6 and
# ACCEPT for everything else, so an explicit ACCEPT is needed to pass traffic.
# There is no need to add rules for return traffic as these are added at the
# top of the ruleset via defaults.yml for maximum efficiency.
#zones:
#  LAN:
#    interfaces:
#      - eth0
#    rules:
#      ip:
#        filter:
#          INPUT:
#            - -j ACCEPT
#          FORWARD:
#            - -j ACCEPT
#          OUTPUT:
#            - -j ACCEPT
#  WAN:
#    interfaces:
#      - eth1
#    rules:
#      ip:
#        filter:
#          OUTPUT:
#            - -j ACCEPT
#        nat:
#          POSTROUTING:
#            - -j MASQUERADE


# Example with zone to zone rules and port forwarding. Use %{zone_name} whenever
# you would use interface names in native iptables to automatically generate the
# needed rules. ${variable} can be used for places where ipsets are overkill or
# can't be used. The variable must be defined as a key in the variables dictionary.

#variables:
#  web_server: 10.0.0.10

#zones:
#  LAN:
#    interfaces:
#      - eth0
#    rules:
#      ip:
#        filter:
#          INPUT:
#            - -j ACCEPT
#          FORWARD:
#            - -j ACCEPT
#          OUTPUT:
#            - -j ACCEPT
#  WAN:
#    interfaces:
#      - eth1
#    rules:
#      ip:
#        filter:
#          FORWARD:
#            - -d ${web_server} -p tcp --dport 80 -j ACCEPT
#          OUTPUT:
#            - -j ACCEPT
#        nat:
#          PREROUTING:
#            - -p tcp --dport 80 -j DNAT --to-destination ${web_server}
#          POSTROUTING:
#            - -j MASQUERADE
#  DMZ:
#    interfaces:
#      - eth2
#    rules:
#      ip:
#        filter:
#          INPUT:
#            - -p icmp --imcp-type echo-request -j ACCEPT
#            - -j CUSTOM_REJECT
#          FORWARD:
#            - -o %{WAN} -j ACCEPT
#            - -j CUSTOM_REJECT
#          OUTPUT:
#            - -j ACCEPT
#        nat:
#          POSTROUTING:
#            - -j MASQUERADE

# vim: ft=yaml
